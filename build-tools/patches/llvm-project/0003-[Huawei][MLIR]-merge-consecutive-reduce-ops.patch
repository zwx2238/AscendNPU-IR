diff --git a/mlir/include/mlir/Dialect/Linalg/IR/LinalgStructuredOps.td b/mlir/include/mlir/Dialect/Linalg/IR/LinalgStructuredOps.td
index ac61117c3d6e..2f8127033d97 100644
--- a/mlir/include/mlir/Dialect/Linalg/IR/LinalgStructuredOps.td
+++ b/mlir/include/mlir/Dialect/Linalg/IR/LinalgStructuredOps.td
@@ -382,6 +382,9 @@ def ReduceOp : LinalgStructuredBase_Op<"reduce", [
 
   let hasCustomAssemblyFormat = 1;
   let hasVerifier = 1;
+#ifdef BSPUB_DAVINCI_BISHENGIR
+  let hasCanonicalizer = 1;
+#endif
 }
 
 
diff --git a/mlir/lib/Dialect/Linalg/IR/LinalgOps.cpp b/mlir/lib/Dialect/Linalg/IR/LinalgOps.cpp
index d1db90bbe2d2..2b1df9720c1f 100644
--- a/mlir/lib/Dialect/Linalg/IR/LinalgOps.cpp
+++ b/mlir/lib/Dialect/Linalg/IR/LinalgOps.cpp
@@ -13,6 +13,7 @@
 #include "mlir/Dialect/Linalg/IR/Linalg.h"
 
 #include "mlir/AsmParser/AsmParser.h"
+#include "mlir/Config/mlir-config.h"
 #include "mlir/Dialect/Affine/IR/AffineOps.h"
 #include "mlir/Dialect/Arith/IR/Arith.h"
 #include "mlir/Dialect/Arith/Utils/Utils.h"
@@ -1734,6 +1735,99 @@ LogicalResult ReduceOp::verify() {
   return success();
 }
 
+#if BSPUB_DAVINCI_BISHENGIR
+struct MergeConsecutiveReduceOp : OpRewritePattern<linalg::ReduceOp> {
+  using OpRewritePattern<linalg::ReduceOp>::OpRewritePattern;
+  LogicalResult matchAndRewrite(linalg::ReduceOp op,
+                                PatternRewriter &rewriter) const override {
+    if (op.getNumDpsInputs() != 1) {
+      return rewriter.notifyMatchFailure(
+          op, "only support second reduce op with one input");
+    }
+    Value input = op.getDpsInputs().front();
+    if (!input.hasOneUse()) {
+      return rewriter.notifyMatchFailure(
+          op, "not support first reduce op result with multiple users");
+    }
+    Operation *inputOp = input.getDefiningOp();
+    auto prevReduce = dyn_cast_or_null<linalg::ReduceOp>(inputOp);
+    if (!prevReduce) {
+      return rewriter.notifyMatchFailure(op, "not find consecutive reduces");
+    }
+    if (!isReduceWithSameRegion(op, prevReduce)) {
+      return rewriter.notifyMatchFailure(
+          op, "not support reduce with different region");
+    }
+    SmallVector<unsigned> dims0;
+    prevReduce.getReductionDims(dims0);
+    SmallVector<unsigned> dims1;
+    op.getReductionDims(dims1);
+    unsigned maxRank = prevReduce.getRank(prevReduce.getDpsInputOperand(0));
+
+    SmallVector<int64_t> dims =
+        mergeConsecutiveReduceDims(dims0, dims1, maxRank);
+    rewriter.setInsertionPointAfter(op);
+    auto newReduce = rewriter.create<linalg::ReduceOp>(
+        op->getLoc(), TypeRange(op->getResults()), prevReduce.getInputs(),
+        op.getInits(), dims);
+    Region &newRegion = newReduce.getRegion();
+    IRMapping mapping;
+    op.getRegion().cloneInto(&newRegion, newRegion.begin(), mapping);
+
+    rewriter.replaceOp(op, newReduce);
+    rewriter.eraseOp(prevReduce);
+    return success();
+  }
+
+  // merge two reduce dims of consecutive reduce ops, return the merged dims
+  // that work on the origin reduce input.
+  // example 1:
+  //   dims0: [0, 1]
+  //   dims1: [0, 1]
+  //   merge result dims: [0, 1, 2, 3]
+  // example 2:
+  //   dims0: [0, 2]
+  //   dims1: [0, 1]
+  //   merge result dims: [0, 1, 2, 3]
+  // example 3:
+  //   dims0: [0, 4]
+  //   dims1: [0, 1]
+  //   merge result dims: [0, 1, 2, 4]
+  SmallVector<int64_t>
+  mergeConsecutiveReduceDims(const SmallVector<unsigned> &dims0,
+                             const SmallVector<unsigned> &dims1,
+                             unsigned maxRank) const {
+    BitVector availableMask(maxRank, true);
+    for (unsigned dim : dims0)
+      availableMask[dim] = false;
+    SmallVector<int64_t> available;
+    for (unsigned i = 0; i < maxRank; i++)
+      if (availableMask[i])
+        available.push_back(i);
+    SmallVector<int64_t> newDims;
+    for (unsigned dim : dims0)
+      newDims.push_back(dim);
+    for (unsigned dim : dims1)
+      newDims.push_back(available[dim]);
+    std::sort(newDims.begin(), newDims.end());
+    return newDims;
+  }
+
+  bool isReduceWithSameRegion(linalg::ReduceOp op1,
+                              linalg::ReduceOp op2) const {
+    return OperationEquivalence::isRegionEquivalentTo(
+        &op1.getRegion(), &op2.getRegion(),
+        OperationEquivalence::Flags::IgnoreLocations);
+  }
+};
+
+void ReduceOp::getCanonicalizationPatterns(RewritePatternSet &results,
+                                           MLIRContext *context) {
+  results.add<MergeConsecutiveReduceOp>(context);
+}
+
+#endif // BSPUB_DAVINCI_BISHENGIR
+
 //===----------------------------------------------------------------------===//
 // TransposeOp
 //===----------------------------------------------------------------------===//
