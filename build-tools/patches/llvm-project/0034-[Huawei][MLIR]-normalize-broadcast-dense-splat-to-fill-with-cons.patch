diff --git a/mlir/include/mlir/Dialect/Linalg/IR/LinalgExtensions.h b/mlir/include/mlir/Dialect/Linalg/IR/LinalgExtensions.h
new file mode 100644
index 000000000000..1d1323bf4dbc
--- /dev/null
+++ b/mlir/include/mlir/Dialect/Linalg/IR/LinalgExtensions.h
@@ -0,0 +1,38 @@
+//===- LinalgExtensions.h - Linalg operations extensions ------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the operation extensions for Linalg operations.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef MLIR_DIALECT_LINALG_IR_LINALGEXTENSIONS_H_
+#define MLIR_DIALECT_LINALG_IR_LINALGEXTENSIONS_H_
+
+#include "mlir/Dialect/Linalg/IR/Linalg.h"
+#include "mlir/Dialect/Tensor/IR/Tensor.h"
+#include "mlir/IR/BuiltinTypeInterfaces.h"
+#include "mlir/IR/BuiltinTypes.h"
+#include "mlir/IR/IRMapping.h"
+#include "mlir/IR/OpDefinition.h"
+#include "mlir/IR/PatternMatch.h"
+#include "mlir/IR/TypeUtilities.h"
+
+namespace mlir {
+namespace linalg {
+
+/// Returns true if value is splat dense, i.e. only has one single element.
+bool isSplatDense(Value value);
+
+/// Create new constant op from splat dense value content.
+std::optional<Value> createConstantFromDenseSplat(Value value,
+                                                  PatternRewriter &rewriter);
+
+} // namespace linalg
+} // namespace mlir
+
+#endif // MLIR_DIALECT_LINALG_IR_LINALGEXTENSIONS_H_
diff --git a/mlir/lib/Dialect/Linalg/IR/CMakeLists.txt b/mlir/lib/Dialect/Linalg/IR/CMakeLists.txt
index c187563b8f0c..ba8bb5a2cb0b 100644
--- a/mlir/lib/Dialect/Linalg/IR/CMakeLists.txt
+++ b/mlir/lib/Dialect/Linalg/IR/CMakeLists.txt
@@ -1,12 +1,23 @@
+set(BS_FEAT_FILES)
+set(BS_FEAT_OPTIONS)
+if(BSPUB_DAVINCI_BISHENGIR)
+  list(APPEND BS_FEAT_FILES LinalgExtensions.cpp)
+else()
+  list(APPEND BS_FEAT_OPTIONS PARTIAL_SOURCES_INTENDED)
+endif()
+
 add_mlir_dialect_library(MLIRLinalgDialect
   LinalgInterfaces.cpp
   LinalgOps.cpp
   LinalgDialect.cpp
   ValueBoundsOpInterfaceImpl.cpp
+  ${BS_FEAT_FILES}
 
   ADDITIONAL_HEADER_DIRS
   ${MLIR_MAIN_INCLUDE_DIR}/mlir/Dialect/Linalg
 
+  ${BS_FEAT_OPTIONS}
+
   DEPENDS
   MLIRLinalgInterfacesIncGen
   MLIRLinalgOpsAttributesIncGen
diff --git a/mlir/lib/Dialect/Linalg/IR/LinalgExtensions.cpp b/mlir/lib/Dialect/Linalg/IR/LinalgExtensions.cpp
new file mode 100644
index 000000000000..de0ffb00be11
--- /dev/null
+++ b/mlir/lib/Dialect/Linalg/IR/LinalgExtensions.cpp
@@ -0,0 +1,65 @@
+//===- LinalgExtensions.cpp - Linalg operations extensions ----------------===//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the operation extensions for Linalg operations.
+//
+//===----------------------------------------------------------------------===//
+
+#include "mlir/Dialect/Linalg/IR/LinalgExtensions.h"
+#include "mlir/Dialect/Arith/IR/Arith.h"
+#include "llvm/ADT/STLExtras.h"
+
+using namespace mlir;
+using namespace mlir::linalg;
+
+//===----------------------------------------------------------------------===//
+// Linalg Operations Extensions
+//===----------------------------------------------------------------------===//
+
+bool mlir::linalg::isSplatDense(Value value) {
+  Operation *defOp = value.getDefiningOp();
+  if (!defOp) {
+    return false;
+  }
+  auto constantOp = dyn_cast_or_null<arith::ConstantOp>(defOp);
+  if (!constantOp) {
+    return false;
+  }
+  auto constValue = constantOp.getValue();
+  auto denseAttr = dyn_cast_or_null<DenseIntOrFPElementsAttr>(constValue);
+  if (!denseAttr || !denseAttr.isSplat()) {
+    return false;
+  }
+  auto elemType = denseAttr.getElementType();
+  return elemType.isIntOrIndexOrFloat();
+}
+
+std::optional<Value>
+mlir::linalg::createConstantFromDenseSplat(Value value,
+                                           PatternRewriter &rewriter) {
+  if (!isSplatDense(value)) {
+    return std::nullopt;
+  }
+  auto op = cast<arith::ConstantOp>(value.getDefiningOp());
+  auto denseAttr = dyn_cast<DenseIntOrFPElementsAttr>(op.getValue());
+  if (!denseAttr || !denseAttr.isSplat()) {
+    return std::nullopt;
+  }
+  Type elemType = denseAttr.getElementType();
+  Location loc = op.getLoc();
+  TypedAttr attr;
+  if (elemType.isInteger()) {
+    APInt value = denseAttr.getSplatValue<APInt>();
+    attr = rewriter.getIntegerAttr(elemType, value);
+  } else if (isa<FloatType>(elemType)) {
+    APFloat value = denseAttr.getSplatValue<APFloat>();
+    attr = rewriter.getFloatAttr(elemType, value);
+  } else {
+    return std::nullopt;
+  }
+  return rewriter.create<arith::ConstantOp>(loc, elemType, attr);
+}
diff --git a/mlir/lib/Dialect/Linalg/IR/LinalgOps.cpp b/mlir/lib/Dialect/Linalg/IR/LinalgOps.cpp
index d49b4ceeae01..9df7d682cd3c 100644
--- a/mlir/lib/Dialect/Linalg/IR/LinalgOps.cpp
+++ b/mlir/lib/Dialect/Linalg/IR/LinalgOps.cpp
@@ -45,6 +45,10 @@
 #include "llvm/Support/raw_ostream.h"
 #include <optional>
 
+#if BSPUB_DAVINCI_BISHENGIR
+#include "mlir/Dialect/Linalg/IR/LinalgExtensions.h"
+#endif
+
 using namespace mlir;
 using namespace mlir::linalg;
 
@@ -2388,9 +2392,53 @@ void BroadcastOp::getEffects(
   getGenericEffectsImpl(effects, cast<LinalgOp>(getOperation()));
 }
 
+#if BSPUB_DAVINCI_BISHENGIR
+namespace {
+class NormalizeBroadcastDenseSplatToFillConstant
+    : public OpRewritePattern<linalg::BroadcastOp> {
+public:
+  using OpRewritePattern<linalg::BroadcastOp>::OpRewritePattern;
+  NormalizeBroadcastDenseSplatToFillConstant(MLIRContext *context)
+      : OpRewritePattern<linalg::BroadcastOp>(context) {}
+
+  LogicalResult matchAndRewrite(linalg::BroadcastOp brcOp,
+                                PatternRewriter &rewriter) const final {
+    if (!brcOp.hasPureTensorSemantics()) {
+      return failure();
+    }
+    Value input = brcOp.getInput();
+    if (!isSplatDense(input)) {
+      return rewriter.notifyMatchFailure(
+          brcOp, "only support broadcast from splat dense.");
+    }
+    Operation *inputOp = input.getDefiningOp();
+    auto constantOp = cast<arith::ConstantOp>(inputOp);
+    auto scalarMaybe = createConstantFromDenseSplat(constantOp, rewriter);
+    if (!scalarMaybe.has_value()) {
+      return rewriter.notifyMatchFailure(constantOp,
+                                         "failed to extract dense constant.");
+    }
+    Value scalar = scalarMaybe.value();
+
+    Location loc = brcOp.getLoc();
+    Value brcInit = brcOp.getInit();
+    auto fillOp = rewriter.create<linalg::FillOp>(
+        loc, TypeRange{brcOp->getResults()}, /*inputs=*/ValueRange{scalar},
+        /*outputs=*/ValueRange{brcInit});
+    rewriter.replaceOp(brcOp, fillOp);
+    return success();
+  }
+};
+
+} // namespace
+#endif
+
 void BroadcastOp::getCanonicalizationPatterns(RewritePatternSet &results,
                                               MLIRContext *context) {
   results.add<EraseIdentityLinalgOp<BroadcastOp>>(context);
+#if BSPUB_DAVINCI_BISHENGIR
+  results.add<NormalizeBroadcastDenseSplatToFillConstant>(context);
+#endif
 }
 
 //===----------------------------------------------------------------------===//
